<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Paul的博客，吐槽下生活！</title><link>https://SevenOfPaul.github.io/paul.github.io</link><description>童话是一种生活态度，仅此而已。</description><copyright>Paul的博客，吐槽下生活！</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://SevenOfPaul.github.io/paul.github.io</link></image><lastBuildDate>Thu, 22 Aug 2024 08:27:53 +0000</lastBuildDate><managingEditor>Paul的博客，吐槽下生活！</managingEditor><ttl>60</ttl><webMaster>Paul的博客，吐槽下生活！</webMaster><item><title>电话号码的字母组合</title><link>https://SevenOfPaul.github.io/paul.github.io/post/dian-hua-hao-ma-de-zi-mu-zu-he.html</link><description># 电话号码的字母组合&#13;
&lt;img width='467' alt='1724315114433' src='https://github.com/user-attachments/assets/986d225a-2961-4cec-baa2-430456c84652'&gt;&#13;
[电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)&#13;
今天依然是很简单的一道题，别看东西那么多，实际上就是多叉树路径，我们要递归的算法，把每一层的结果保存存入下一层，长度符合要求就存进vec中&#13;
![image](https://github.com/user-attachments/assets/e6c4f583-5088-4403-9625-c0238b9df44e)&#13;
## 入口函数&#13;
```rust&#13;
use std::collections::HashMap;&#13;
impl Solution {&#13;
    pub fn letter_combinations(digits: String) -&gt; Vec&lt;String&gt; {&#13;
&#13;
        let mut ans:Vec&lt;String&gt;=vec![];&#13;
        if digits.len()==0{&#13;
            return ans;&#13;
        }&#13;
        let map = HashMap::from([&#13;
            (2, vec!('a', 'b', 'c')),&#13;
            (3, vec!('d', 'e', 'f')),&#13;
            (4, vec!('g', 'h', 'i')),&#13;
            (5, vec!('j', 'k', 'l')),&#13;
            (6, vec!('m', 'n', 'o')),&#13;
            (7, vec!('p', 'q', 'r', 's')),&#13;
            (8, vec!('t', 'u', 'v')),&#13;
            (9, vec!('w', 'x', 'y', 'z'))&#13;
        ]);&#13;
  let len=digits.len();&#13;
            Self::addVec(digits.chars().collect(),0,map.clone(),String::from(''),&amp;mut ans,len);&#13;
        ans&#13;
    }&#13;
```&#13;
## 递归函数&#13;
```rust&#13;
 pub fn addVec(digits:Vec&lt;char&gt;,idx:usize,map:HashMap&lt;i32,Vec&lt;char&gt;&gt;, origin:String, ans:&amp;mut Vec&lt;String&gt;,len:usize){&#13;
        if origin.len()==len{&#13;
              ans.push(origin);&#13;
      }else{&#13;
            let strs=map.get(&amp;(digits[idx] as i32 - '0' as i32)).unwrap();&#13;
          for str in strs {&#13;
             Self::addVec(digits.clone(),idx+1,map.clone(),(origin.clone()+ &amp;*str.to_string()),ans,len);&#13;
          }&#13;
      }&#13;
    }&#13;
}&#13;
```。</description><guid isPermaLink="true">https://SevenOfPaul.github.io/paul.github.io/post/dian-hua-hao-ma-de-zi-mu-zu-he.html</guid><pubDate>Thu, 22 Aug 2024 08:24:18 +0000</pubDate></item><item><title>二叉树路径</title><link>https://SevenOfPaul.github.io/paul.github.io/post/er-cha-shu-lu-jing.html</link><description># 二叉树路径&#13;
今天我们来聊聊二叉树，二叉树是一种非常常见的数据结构了，也是很基础的数据结构。</description><guid isPermaLink="true">https://SevenOfPaul.github.io/paul.github.io/post/er-cha-shu-lu-jing.html</guid><pubDate>Sun, 07 Jul 2024 10:52:29 +0000</pubDate></item><item><title>cpp中的const 关键字</title><link>https://SevenOfPaul.github.io/paul.github.io/post/cpp-zhong-de-const%20-guan-jian-zi.html</link><description>#const 关键字&#13;
&#13;
const关键字修饰的所有变量会保存在存储区区域，同时在获取地址时会在栈上分配一个空间&#13;
&#13;
## 基本数据类型 ##&#13;
&#13;
``````cpp&#13;
//存储区存储&#13;
const int data=1;&#13;
//在栈上分配内存返回地址也是栈上的&#13;
int *ptr2=(int*)&amp;data;&#13;
//修改的地址是栈上的地址&#13;
 *ptr2=10;&#13;
  cout&lt;&lt;'data='&lt;&lt;data&lt;&lt;'*p='&lt;&lt;*ptr2&lt;&lt;endl;&#13;
//data=1*p=10 存储区区域的数据不变&#13;
``````&#13;
&#13;
## 引用数据类型 ##&#13;
&#13;
引用数据类型和基本数据类型差距比较大&#13;
&#13;
``````cpp&#13;
//数据存储在堆上，存储区区域存储地址  &#13;
const Obj obj={'小红',12};&#13;
//读取到的地址是堆上的&#13;
    Obj *p=(Obj*)&amp;obj;&#13;
//直接修改堆上的数据&#13;
 p-&gt;name='小安';&#13;
 cout&lt;&lt;obj.name&lt;&lt;endl;&#13;
``````&#13;
&#13;
&#13;
&#13;
。</description><guid isPermaLink="true">https://SevenOfPaul.github.io/paul.github.io/post/cpp-zhong-de-const%20-guan-jian-zi.html</guid><pubDate>Fri, 05 Jul 2024 12:15:20 +0000</pubDate></item><item><title>玩个大活：自定义JSON（1）</title><link>https://SevenOfPaul.github.io/paul.github.io/post/wan-ge-da-huo-%EF%BC%9A-zi-ding-yi-JSON%EF%BC%881%EF%BC%89.html</link><description>今天我们来玩个大活：用cpp写一个**自定义JSON解析器**，第一天我们先来简单介绍下JSON，&#13;
## JSON类型介绍&#13;
类型 | 描述&#13;
-- | --&#13;
数字型（Number） | JavaScript 中的双精度浮点型格式&#13;
字符串型（String） | 双引号包裹的 Unicode 字符和反斜杠转义字符&#13;
布尔型（Boolean） | true 或 false&#13;
数组（Array） | 有序的值序列&#13;
值（Value） | 可以是字符串，数字，true 或 false，null 等等&#13;
对象（Object） | 无序的键:值对集合&#13;
空格（Whitespace） | 可用于任意符号对之间&#13;
null | 空&#13;
&#13;
使用JSON最简单的方式就是打开浏览器使用浏览器自带的js&#13;
```typescript&#13;
const str=JSON.stringify({name:'张三'});&#13;
const obj=JSON.parse(str);&#13;
console.log(str,obj);&#13;
```&#13;
![1720103016669](https://github.com/SevenOfPaul/paul.github.io/assets/83870824/a031e40d-f4b3-48da-86c6-1a56d5e310dd)&#13;
## 设置接口&#13;
我们可以使用`enum class`语法来定义MyJson的类型&#13;
```cpp&#13;
enum class JsonType {&#13;
    Null,Number,Boolean,String,Array,Object&#13;
};&#13;
```&#13;
欲知后事如何，且听下回分解。</description><guid isPermaLink="true">https://SevenOfPaul.github.io/paul.github.io/post/wan-ge-da-huo-%EF%BC%9A-zi-ding-yi-JSON%EF%BC%881%EF%BC%89.html</guid><pubDate>Thu, 04 Jul 2024 14:25:50 +0000</pubDate></item><item><title>力扣算法第二题 加一</title><link>https://SevenOfPaul.github.io/paul.github.io/post/li-kou-suan-fa-di-er-ti-%20-jia-yi.html</link><description># 力扣算法第二题 加一&#13;
本题的难点在于**进位** 出现9的时候就需要变成10，而题目要求每个位置只能保存一个单位的数字。</description><guid isPermaLink="true">https://SevenOfPaul.github.io/paul.github.io/post/li-kou-suan-fa-di-er-ti-%20-jia-yi.html</guid><pubDate>Tue, 02 Jul 2024 09:39:24 +0000</pubDate></item><item><title>力扣算法第一题 两数之和</title><link>https://SevenOfPaul.github.io/paul.github.io/post/li-kou-suan-fa-di-yi-ti-%20-liang-shu-zhi-he.html</link><description>**力扣算法第一题 两数之和是非常简单的一道题**&#13;
![1719896970686](https://github.com/SevenOfPaul/paul.github.io/assets/83870824/f1740bed-69aa-480b-b571-14c80101c5aa)&#13;
由于是简单题，只需要简单的暴力就可以做到了，&#13;
我们首先用冒泡排序的方式来一对一的对比。</description><guid isPermaLink="true">https://SevenOfPaul.github.io/paul.github.io/post/li-kou-suan-fa-di-yi-ti-%20-liang-shu-zhi-he.html</guid><pubDate>Tue, 02 Jul 2024 05:13:55 +0000</pubDate></item></channel></rss>